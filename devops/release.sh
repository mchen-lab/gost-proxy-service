# ===== AUTO-GENERATED BY APP-KIT - DO NOT EDIT =====
# This file is managed by @mchen-lab/app-kit and will be
# overwritten when running `npx @mchen-lab/app-kit update`.
# Version: 0.1.6
# ====================================================

#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR/.."

# Find config file
if [ ! -f "./devops.config.json" ]; then
    echo "‚ùå Error: devops.config.json not found"
    exit 1
fi

# Read config values using node
read_config() {
    node -p "require('./devops.config.json').$1 || ''"
}

PROJECT_NAME=$(read_config "projectName")
PACKAGE_JSON_PATH=$(read_config "packageJsonPath")
PACKAGE_JSON_PATH="${PACKAGE_JSON_PATH:-.}"

# Help / Usage
if [ "$1" == "--help" ]; then
    echo "Usage: ./devops/release.sh [patch|minor|major|<version>]"
    echo "       ./devops/release.sh           # Re-release current version"
    echo ""
    echo "Project: $PROJECT_NAME"
    exit 0
fi

BUMP_TYPE=$1

echo "=== üöÄ Release Script for $PROJECT_NAME ==="

# 1. Ensure git is clean
if [[ -n $(git status -s) ]]; then
    echo "‚ùå Error: Git working directory is not clean. Please commit or stash changes first."
    exit 1
fi

# 2. Ensure we're on the main branch
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    echo "‚ùå Error: You must be on the 'main' branch to release. Currently on '$CURRENT_BRANCH'."
    exit 1
fi

# 3. Ensure local main is up-to-date with remote
echo "üîÑ Fetching latest from origin..."
git fetch origin main
LOCAL_COMMIT=$(git rev-parse HEAD)
REMOTE_COMMIT=$(git rev-parse origin/main)

if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
    echo "‚ùå Error: Local 'main' is not in sync with 'origin/main'."
    echo "   Local:  $LOCAL_COMMIT"
    echo "   Remote: $REMOTE_COMMIT"
    echo "   Please run 'git pull' or 'git push' first."
    exit 1
fi

# Determine package.json location
if [ "$PACKAGE_JSON_PATH" == "." ]; then
    PKG_JSON="./package.json"
    PKG_LOCK="./package-lock.json"
else
    PKG_JSON="$PACKAGE_JSON_PATH/package.json"
    PKG_LOCK="$PACKAGE_JSON_PATH/package-lock.json"
fi

if [ -z "$BUMP_TYPE" ]; then
    echo "=== üöÄ Re-Releasing Current Version ==="
    VERSION_NUM=$(node -p "require('$PKG_JSON').version")
    echo "‚ÑπÔ∏è  Current version: $VERSION_NUM"
    FORCE_RE_RELEASE="true"
else
    echo "=== üöÄ Starting Release: $BUMP_TYPE ==="
    
    if [ "$PACKAGE_JSON_PATH" != "." ]; then
        cd "$PACKAGE_JSON_PATH"
    fi
    NEW_VERSION=$(npm version $BUMP_TYPE --no-git-tag-version)
    if [ "$PACKAGE_JSON_PATH" != "." ]; then
        cd - > /dev/null
    fi
    VERSION_NUM=${NEW_VERSION#v}
    echo "üìù Bumped version to $VERSION_NUM"
fi

# 4. Git Commit and Tag
echo "üì¶ Committing and Tagging..."
git add "$PKG_JSON"
[ -f "$PKG_LOCK" ] && git add "$PKG_LOCK"

if ! git diff-index --quiet HEAD; then
    git commit -m "chore: release v$VERSION_NUM" || echo "‚ö†Ô∏è  Nothing to commit."
else
    echo "‚ÑπÔ∏è  No changes to commit (version unchanged)."
fi

TAG_NAME="v$VERSION_NUM"

if [ "$FORCE_RE_RELEASE" = "true" ]; then
    echo "üî• Re-release mode: Removing existing tag '$TAG_NAME' from remote and local..."
    git push origin --delete "$TAG_NAME" 2>/dev/null || echo "   (Remote tag didn't exist)"
    git tag -d "$TAG_NAME" 2>/dev/null || echo "   (Local tag didn't exist)"
fi

git tag -f -a "$TAG_NAME" -m "Release $TAG_NAME"
echo "‚úÖ Created local tag: $TAG_NAME"

echo "‚¨ÜÔ∏è  Pushing to origin..."
git push origin main
git push origin "$TAG_NAME"

echo ""
echo "üéâ Release $TAG_NAME completed successfully!"

echo ""
echo "=== üê≥ Building and Publishing Production Image ==="

# Define Image Names (re-read in case they changed, though unlikely)
GHCR_IMAGE="ghcr.io/$GHCR_ORG/$IMAGE_NAME"
DOCKERHUB_IMAGE="$DOCKERHUB_USER/$IMAGE_NAME"

BUILDER_NAME="${IMAGE_NAME}-builder"

# Setup buildx
if ! docker buildx inspect "$BUILDER_NAME" > /dev/null 2>&1; then
    echo "Creating new buildx builder..."
    docker buildx create --name "$BUILDER_NAME" --use
    docker buildx inspect --bootstrap
else
    docker buildx use "$BUILDER_NAME"
fi

# Build Metadata for Prod
BUILD_META="-prod-$(date +%Y%m%d)"
COMMIT_HASH=$(git rev-parse --short HEAD)

# Tags
# We push:
# 1. vX.Y.Z
# 2. vX.Y
# 3. vX
# 4. latest
TAGS="-t $GHCR_IMAGE:$VERSION_NUM -t $GHCR_IMAGE:latest"
TAGS="$TAGS -t $GHCR_IMAGE:$MAJOR.$MINOR -t $GHCR_IMAGE:$MAJOR"

if [ -n "$DOCKERHUB_USER" ]; then
    TAGS="$TAGS -t $DOCKERHUB_IMAGE:$VERSION_NUM -t $DOCKERHUB_IMAGE:latest"
    TAGS="$TAGS -t $DOCKERHUB_IMAGE:$MAJOR.$MINOR -t $DOCKERHUB_IMAGE:$MAJOR"
fi

echo "Building with versions: $VERSION_NUM $BUILD_META"
echo "Commit: $COMMIT_HASH"

docker buildx build \
  --platform linux/amd64,linux/arm64 \
  --build-arg BUILD_METADATA="$BUILD_META" \
  --build-arg GIT_COMMIT="$COMMIT_HASH" \
  $TAGS \
  --push \
  .

echo ""
echo "‚úÖ Production build published!"
